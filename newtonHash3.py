#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Mon Feb  5 20:01:53 2018

@author: ngoc

Using the pickled UT2 data generated by newtonHash.py, 
compute (exhaustively) identities for UT3
for words of length 20 (!)
"""
import newtonHash as newtonHash
import newton3 as newton3
import numpy as np
import itertools as itt
import cPickle
from util import *

def huntHash(dicval, start=0,end=None):
  """find ONE w ~ w' identity for UT3
  based on the ut2 identities. 
  input: dic = dict(na)(nb): a dictionary of ut2 identities,
  computed with newtonHash
  method: for each value in dictionary, if it is NOT an isoterm, compute its UT3 signature, store in a local dictionary (which correspond to the UT3 classes
that split from a single UT2 class). Check if the dictionary has any entry with length > 1.
  If found one, return it straight away. 
  This function is to prove that there are NO UT3 identities of length <= 21.
  Currently: if an exception from scipy is raised when computing UT3 signatures (due to the polytope being low-dimensional), then do a pairwise comparison of all words amongst this class. 
  """  
  if end is None:
    end = len(dicval)
  for i in xrange(start,end):
    wordList = dicval[i]
    if i % 5000 == 0:
      print "i = " + str(i)
    #simpler version when there are only 2 words
    if len(wordList) == 2:
      w,w2 = wordList
      if newton3.equal3fast(w,w2):
        print "found one!"
        return (w,w2)
    if len(wordList) > 2:      
      #compute the signature
      try:
        localdic = {}
        for word in wordList:
          signature = newton3.getSignature(word)
          newtonHash._addToDict(localdic,signature,word)
        #if find an identity, return all the appropriate entries.
        localdicval = localdic.values()
        hasIdentity = np.array(map(len,localdic.values())) > 1
        if any(hasIdentity):
          for i in xrange(len(hasIdentity)):
            if hasIdentity[i]:
              print "found one!"
              return localdicval[i]
      except:
        print "signature computation has issues. Back to pairwise"
        pairgen = itt.combinations(wordList,2)
        for pair in pairgen:
          w,w2 = pair
          try:
            if newton3.equal3fast(w,w2):
              print "found one!"
              return (w,w2)
          except:
            print "error in computing equal3 for i =" + str(i)
            return (w,w2)        
  return (None,None)

#--- Hash version of all ut3 identities hunt.
def allUT3Hash(dictn,dickey,start=0,end=None):
  """find ALL identities for UT3
  based on the ut2 identities. 
  input: dic = dict(na)(nb): a dictionary of ut2 identities,
  computed with newtonHash
  method: for each value in dictionary, if it is NOT an isoterm, 
  * pass through the list once. 
  * compute the signature UT3 polytope for each of the word in this list
  * store in a small dictionary
  * only keep words in the dictionary of length at least 2. 
  * retain this into a big dictionary. 
  If throw scipy.ConvexHull throws an exception (due to low dimensional polytopes), go back to pairwise comparison.
  """
  bigdic = {}
  if end is None:
    end = len(dickey)
  for i in xrange(start,end):
    wordList = dictn[dickey[i]]
    if i % 5000 == 0:
      print "i = " + str(i)
    #simpler version when there are only 2 words
    if len(wordList) == 2:
      w,w2 = wordList
      if newton3.equal3fast(w,w2):
        print "found one!"
        newtonHash._addToDict(bigdic,dickey[i],w)
        newtonHash._addToDict(bigdic,dickey[i],w2)
    if len(wordList) > 2:      
      try:
        #compute the signature
        localdic = {}
        for word in wordList:
          signature = newton3.getSignature(word)
          newtonHash._addToDict(localdic,signature,word)
        #only keep entries of localdic with length > 1
        for key in localdic.iterkeys():
          vals = localdic[key]
          if len(vals) > 1:
            print "found one!"
            newtonHash._addToDict(bigdic,key,vals)
      except:
        print "signature computation has issues. Back to pairwise"
        pairgen = itt.combinations(wordList,2)
        for pair in pairgen:
          w,w2 = pair
          if newton3.equal3fast(w,w2):
            print "found one!"
            newtonHash._addToDict(bigdic,dickey[i],w)
            newtonHash._addToDict(bigdic,dickey[i],w2)        
  return bigdic
  





